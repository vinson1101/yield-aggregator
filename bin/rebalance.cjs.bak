#!/usr/bin/env node
/**
 * Yield Aggregator - è‡ªåŠ¨åˆ‡æ¢ + å®æ—¶ APY
 */

const { createWalletClient, http, encodeFunctionData } = require('viem');
const { privateKeyToAccount } = require('viem/accounts');
const { base } = require('viem/chains');

const PRIVATE_KEY = process.env.EVM_PRIVATE_KEY || '0x29b5a88baa09054abdbf18bfc6deaebe9acafd43a2730e5d42dae29f51e36675';
const WALLET = '0x1758DE3E2cf746F4eEb7143c3935fCa1B30060ce';

const USDC = '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913';
const AAVE_POOL = '0xa238dd80c259a72e81d7e4664a9801593f98d1c5';
const AAVE_ATOKEN = '0x4e65fe4dba92790696d040ac24aa414708f5c0ab';
const MORPHO = '0x8A034f069D59d62a4643ad42E49b846d036468D7';
const MOONWELL = '0xedc817a28e8b93b03976fbd4a3ddbc9f7d176c22';




const ERC20 = [
  { name: 'approve', type: 'function', inputs: [{ name: 'spender', type: 'address' }, { name: 'amount', type: 'uint256' }], outputs: [{ type: 'bool' }], stateMutability: 'nonpayable' },
  { name: 'balanceOf', type: 'function', inputs: [{ name: 'owner', type: 'address' }], outputs: [{ type: 'uint256' }], stateMutability: 'view' },
  { name: 'transfer', type: 'function', inputs: [{ name: 'to', type: 'address' }, { name: 'amount', type: 'uint256' }], outputs: [{ type: 'bool' }], stateMutability: 'nonpayable' }
];

const AAVE_ABI = [
  { name: 'supply', type: 'function', inputs: [{ name: 'asset', type: 'address' }, { name: 'amount', type: 'uint256' }, { name: 'onBehalfOf', type: 'address' }, { name: 'referralCode', type: 'uint16' }], outputs: [], stateMutability: 'nonpayable' },
  { name: 'withdraw', type: 'function', inputs: [{ name: 'asset', type: 'address' }, { name: 'amount', type: 'uint256' }, { name: 'to', type: 'address' }], outputs: [], stateMutability: 'nonpayable' }
];

const MORPHO_ABI = [
  { name: 'deposit', type: 'function', inputs: [{ name: 'assets', type: 'uint256' }, { name: 'receiver', type: 'address' }], outputs: [{ type: 'uint256' }], stateMutability: 'nonpayable' },
  { name: 'withdraw', type: 'function', inputs: [{ name: 'assets', type: 'uint256' }, { name: 'receiver', type: 'address' }, { name: 'owner', type: 'address' }], outputs: [{ type: 'uint256' }], stateMutability: 'nonpayable' }
];

// Moonwell USDC Vault (ERC4626)
const MOONWELL_ABI = [
  { name: 'deposit', type: 'function', inputs: [{ name: 'assets', type: 'uint256' }, { name: 'receiver', type: 'address' }], outputs: [{ type: 'uint256' }], stateMutability: 'nonpayable' },
  { name: 'redeem', type: 'function', inputs: [{ name: 'shares', type: 'uint256' }, { name: 'receiver', type: 'address' }, { name: 'owner', type: 'address' }], outputs: [{ type: 'uint256' }], stateMutability: 'nonpayable' }
];

// çŠ¶æ€æ–‡ä»¶
const STATE_FILE = '/root/.openclaw/workspace/yield-aggregator/data/state.json';
const HISTORY_FILE = '/root/.openclaw/workspace/yield-aggregator/data/history.json';
const fs = require('fs');

function loadState() {
  try {
    if (fs.existsSync(STATE_FILE)) {
      return JSON.parse(fs.readFileSync(STATE_FILE, 'utf8'));
    }
  } catch (e) {}
  return { shares: {}, lastCheck: null };
}

function saveState(state) {
  fs.writeFileSync(STATE_FILE, JSON.stringify(state, null, 2));
}

function loadHistory() {
  try {
    if (fs.existsSync(HISTORY_FILE)) {
      return JSON.parse(fs.readFileSync(HISTORY_FILE, 'utf8'));
    }
  } catch (e) {}
  return [];
}

function saveHistory(history) {
  fs.writeFileSync(HISTORY_FILE, JSON.stringify(history, null, 2));
}

// å¸¦é‡è¯•çš„äº¤æ˜“å‡½æ•°
async function sendTx(wallet, config) {
  const { abi, address, functionName, args, retries = 3 } = config;
  
  for (let i = 0; i < retries; i++) {
    try {
      // ä¼°ç®— Gas
      try {
        const gas = await wallet.estimateGas({
          account: wallet.account,
          to: address,
          data: encodeFunctionData({ abi, functionName, args })
        });
        config.gas = BigInt(Math.floor(Number(gas) * 1.2)); // +20% buffer
        console.log(`   â›½ é¢„ä¼° Gas: ${config.gas}`);
      } catch (e) {
        console.log(`   âš ï¸ Gas ä¼°ç®—å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼`);
      }
      
      const tx = await wallet.writeContract(config);
      return tx;
    } catch (e) {
      if (i < retries - 1 && e.message?.includes('insufficient')) {
        console.log(`   âš ï¸ äº¤æ˜“å¤±è´¥ï¼Œé‡è¯• ${i+1}/${retries}...`);
        await new Promise(r => setTimeout(r, 3000));
        continue;
      }
      throw e;
    }
  }
  throw new Error('é‡è¯•æ¬¡æ•°è¿‡å¤š');
}

async function getAPY() {
  let aaveApy = 0.035;
  let morphoApy = 0.098;
  
  try {
    const { execSync } = require("child_process");
    try {
      const m = JSON.parse(execSync("defi lend rates --protocol morpho --chain base --asset USDC 2>/dev/null", { encoding: "utf8" }));
      if (m.success && m.data.length > 0) {
        morphoApy = Math.max(...m.data.map(d => d.supply_apy)) / 100;
        console.log("ğŸ“¡ Morpho: " + (morphoApy*100).toFixed(1) + "%");
      }
    } catch (e) {}
    try {
      const a = JSON.parse(execSync("defi lend rates --protocol aave --chain base --asset USDC 2>/dev/null", { encoding: "utf8" }));
      if (a.success && a.data.length > 0) {
        aaveApy = Math.max(...a.data.map(d => d.supply_apy)) / 100;
        console.log("ğŸ“¡ Aave: " + (aaveApy*100).toFixed(1) + "%");
      }
    } catch (e) {}
  } catch (e) {}
  
  let moonwellApy = 0;
try {
  const resp = await fetch("https://yields.llama.fi/pools");
  const data = await resp.json();
  for (const p of data.data || []) {
    if (p.chain === "Base" && p.symbol === "USDC" && p.project === "moonwell-lending") {
      moonwellApy = p.apy / 100;
      console.log("ğŸ“¡ Moonwell: " + (moonwellApy*100).toFixed(1) + "%");
      break;
    }
  }
} catch (e) {}

  return { aaveApy, morphoApy, moonwellApy };
}

async function main() {
  const action = process.argv[2] || 'check';
  
  const account = privateKeyToAccount(PRIVATE_KEY);
  const wallet = createWalletClient({ chain: base, transport: http(), account });
  const { createPublicClient } = require('viem');
  const publicClient = createPublicClient({ chain: base, transport: http() });

  const { aaveApy, morphoApy, moonwellApy } = await getAPY();

console.log('=== Yield Aggregator (EOA) ===\n');

  const usdcBalance = await publicClient.readContract({ address: USDC, abi: ERC20, functionName: 'balanceOf', args: [WALLET] });
  const aaveBalance = await publicClient.readContract({ address: AAVE_ATOKEN, abi: ERC20, functionName: 'balanceOf', args: [WALLET] });
  const morphoShares = await publicClient.readContract({ address: MORPHO, abi: ERC20, functionName: 'balanceOf', args: [WALLET] });
  const moonwellShares = await publicClient.readContract({ address: MOONWELL, abi: ERC20, functionName: 'balanceOf', args: [WALLET] });

  console.log('ğŸ“Š å½“å‰çŠ¶æ€:');
  console.log(`  Wallet USDC: ${Number(usdcBalance) / 1e6}`);
  console.log(`  Aave aUSDC:  ${Number(aaveBalance) / 1e6} (APY: ${aaveApy * 100}%)`);
  console.log(`  Morpho:     ${Number(morphoShares) / 1e18} shares (APY: ${morphoApy * 100}%)`);
  if (moonwellApy > 0) {
    console.log(`  Moonwell:    ${Number(moonwellShares) / 1e18} shares (APY: ${moonwellApy * 100}%)`);
  }
  console.log('');

  if (action === 'check') {
    const totalAave = Number(aaveBalance) / 1e6;
    const totalMorpho = Number(morphoShares) / 1e18;
    
    console.log('ğŸ“ˆ æ”¶ç›Šæ¯”è¾ƒ:');
    
    // æ”¶ç›Šè¿½è¸ª
    const state = loadState();
    const history = loadHistory();
    const now = Date.now();
    
    // è®°å½•å½“å‰
    const currentProtocol = totalMorpho > 0.001 ? 'Morpho' : (totalAave > 0.001 ? 'Aave' : (totalMoonwell > 0.001 ? 'Moonwell' : null));
    if (currentProtocol) {
      const currentShares = totalMorpho > 0.001 ? totalMorpho : (totalAave > 0.001 ? totalAave : totalMoonwell);
      
      if (!state.shares) state.shares = {};
      if (!state.shares[currentProtocol]) {
        state.shares[currentProtocol] = { shares: currentShares, value: 5, time: now };
        console.log('ğŸ“ é¦–æ¬¡è®°å½•æ”¶ç›ŠåŸºå‡†');
      } else {
        const last = state.shares[currentProtocol];
        const days = (now - last.time) / (1000*60*60*24);
        
        if (days > 0) {
          const shareChange = currentShares - last.shares;
          const valueChange = shareChange * 5 / last.shares; // ä¼°ç®—
          const apy = (valueChange / 5 / days) * 365 * 100;
          
          if (valueChange > 0) {
            console.log(`ğŸ’° å®é™…æ”¶ç›Š: +$${valueChange.toFixed(4)} (${days.toFixed(1)}å¤©), æ¨ç®—å¹´åŒ–: ${apy.toFixed(1)}%`);
          }
        }
        
        state.shares[currentProtocol] = { shares: currentShares, value: 5, time: now };
      }
      state.lastCheck = now;
      saveState(state);
      
      // ä¿å­˜å†å²
      history.push({
        time: new Date().toISOString(),
        protocol: currentProtocol,
        shares: currentShares,
        apy: currentProtocol === 'Morpho' ? morphoApy : (currentProtocol === 'Aave' ? aaveApy : moonwellApy)
      });
      if (history.length > 30) history.shift();
      saveHistory(history);
    }
    console.log(`  Aave:   ${aaveApy * 100}% â†’ å¹´æ”¶ç›Š: $${(totalAave * aaveApy).toFixed(4)}`);
    console.log(`  Morpho: ${morphoApy * 100}% â†’ å¹´æ”¶ç›Š: $${(totalMorpho * morphoApy).toFixed(4)}\n`);
    
    if (totalMorpho > 0 && totalAave > 0) {
      if (morphoApy > aaveApy) {
        console.log(`ğŸ¯ å»ºè®®: ä» Aave åˆ‡æ¢åˆ° Morpho (å¤šèµš ${(morphoApy - aaveApy) * 100}%)`);
      }
    } else if (totalAave > 0) {
      console.log(`ğŸ¯ å»ºè®®: åˆ‡æ¢åˆ° Morpho`);
    } else if (totalMorpho > 0) {
      console.log('ğŸ’¤ å½“å‰å·²æ˜¯æœ€é«˜æ”¶ç›Š (Morpho)');
    }
    return;
  }

  if (action === 'switch' || action === 'auto' || action === 'dry-run') {
    
    const isDryRun = action === 'dry-run';
    if (isDryRun) {
      console.log('ğŸ” æ¨¡æ‹Ÿè¿è¡Œæ¨¡å¼ (ä¸ä¼šçœŸæ­£äº¤æ˜“)\n');
    }
    // æ”¶é›†æ‰€æœ‰æœ‰å­˜æ¬¾çš„åè®®
    const totalAave = Number(aaveBalance) / 1e6;
    const totalMorpho = Number(morphoShares) / 1e18;
    const totalMoonwell = Number(moonwellShares) / 1e18;
    
    // å½“å‰åè®®
    let current = null;
    if (totalMorpho > 0.001) current = { name: 'Morpho', apy: morphoApy, amount: totalMorpho };
    else if (totalAave > 0.001) current = { name: 'Aave', apy: aaveApy, amount: totalAave };
    else if (totalMoonwell > 0.001) current = { name: 'Moonwell', apy: moonwellApy, amount: totalMoonwell };
    
    // æ‰¾å‡ºæœ€é«˜ APY
    const best = [
      { name: 'Morpho', apy: morphoApy },
      { name: 'Aave', apy: aaveApy },
      { name: 'Moonwell', apy: moonwellApy }
    ].sort((a, b) => b.apy - a.apy)[0];
    
    if (!current) {
      console.log('ğŸ’¤ æ— å­˜æ¬¾ï¼Œè¯·å…ˆå­˜å…¥');
      return;
    }
    
    const diff = best.apy - current.apy;
    console.log(`ğŸ“ˆ å½“å‰: ${current.name} @ ${(current.apy*100).toFixed(1)}% â†’ æœ€ä½³: ${best.name} @ ${(best.apy*100).toFixed(1)}%`);
    console.log(`   æ”¶ç›Šå·®: ${(diff*100).toFixed(2)}%\n`);
    
    // è‡ªåŠ¨æ¨¡å¼ï¼šåªæœ‰æ”¶ç›Šå·® > 1% æ‰åˆ‡æ¢
    if (action === 'auto' && diff < 0.01) {
      console.log('ğŸ’¤ æ”¶ç›Šå·® < 1%ï¼Œä¸åˆ‡æ¢');
      return;
    }
    
    if (current.name === best.name) {
      console.log('ğŸ’¤ å½“å‰å·²æ˜¯æœ€é«˜æ”¶ç›Š');
      return;
    }
    
    // æ‰§è¡Œåˆ‡æ¢
    console.log(`ğŸ”„ ä» ${current.name} åˆ‡æ¢åˆ° ${best.name}...\n`);
    
    // 1. ä»å½“å‰åè®®å–æ¬¾
    let sourceToken;
    if (current.name === 'Aave') {
      sourceToken = aaveBalance;
      console.log(`1ï¸âƒ£ ä» Aave å–æ¬¾...`);
      const tx1 = await sendTx(wallet, {
        address: AAVE_POOL, abi: AAVE_ABI, functionName: 'withdraw',
        args: [USDC, aaveBalance, WALLET]
      });
      console.log(`   TX: https://basescan.org/tx/${tx1}`);
    } else if (current.name === 'Morpho') {
      sourceToken = morphoShares;
      console.log(`1ï¸âƒ£ ä» Morpho å–æ¬¾...`);
      const tx1 = await sendTx(wallet, {
        address: MORPHO, abi: MORPHO_ABI, functionName: 'withdraw',
        args: [morphoShares, WALLET, WALLET],
        abi: MORPHO_ABI, functionName: 'withdraw', address: MORPHO
      });
      console.log(`   TX: https://basescan.org/tx/${tx1}`);
    } else if (current.name === 'Moonwell') {
      sourceToken = moonwellShares;
      console.log(`1ï¸âƒ£ ä» Moonwell å–æ¬¾...`);
      const tx1 = await sendTx(wallet, {
        address: MOONWELL, abi: MOONWELL_ABI, functionName: 'redeem',
        args: [moonwellShares, WALLET, WALLET]
      });
      console.log(`   TX: https://basescan.org/tx/${tx1}`);
    }
    
    await new Promise(r => setTimeout(r, 5000));
    
    // 2. è·å– USDC ä½™é¢å¹¶ approve
    const usdcBal = await publicClient.readContract({ address: USDC, abi: ERC20, functionName: 'balanceOf', args: [WALLET] });
    console.log(`2ï¸âƒ£ å­˜å…¥ ${best.name}...`);
    
    if (best.name === 'Morpho') {
      await sendTx(wallet, { address: USDC, abi: ERC20, functionName: 'approve', args: [MORPHO, usdcBal] });
      const tx2 = await sendTx(wallet, {
        address: MORPHO, abi: MORPHO_ABI, functionName: 'deposit',
        args: [usdcBal, WALLET]
      });
      console.log(`   TX: https://basescan.org/tx/${tx2}`);
    } else if (best.name === 'Aave') {
      await sendTx(wallet, { address: USDC, abi: ERC20, functionName: 'approve', args: [AAVE_POOL, usdcBal] });
      const tx2 = await sendTx(wallet, {
        address: AAVE_POOL, abi: AAVE_ABI, functionName: 'supply',
        args: [USDC, usdcBal, WALLET, 0]
      });
      console.log(`   TX: https://basescan.org/tx/${tx2}`);
    } else if (best.name === 'Moonwell') {
      await sendTx(wallet, { address: USDC, abi: ERC20, functionName: 'approve', args: [MOONWELL, usdcBal] });
      const tx2 = await sendTx(wallet, {
        address: MOONWELL, abi: MOONWELL_ABI, functionName: 'deposit',
        args: [usdcBal, WALLET]
      });
      console.log(`   TX: https://basescan.org/tx/${tx2}`);
    }
    
    console.log('\nâœ… åˆ‡æ¢å®Œæˆ!');
    
    // å‘é€ Telegram é€šçŸ¥
    try {
      const { execSync } = require('child_process');
      const msg = `ğŸ”„ Yield è‡ªåŠ¨åˆ‡æ¢å®Œæˆ\nä»: ${current.name} (${(current.apy*100).toFixed(1)}%)\nåˆ°: ${best.name} (${(best.apy*100).toFixed(1)}%)\næ”¶ç›Šå·®: +${(diff*100).toFixed(1)}%`;
      execSync(`openclaw message send --target 8270921141 --message "${msg}" 2>/dev/null`, { encoding: 'utf8' });
    } catch (e) {
      console.log('âš ï¸ é€šçŸ¥å‘é€å¤±è´¥');
    }
  }
}

main().catch(console.error);
