#!/usr/bin/env node
/**
 * Yield Aggregator - è‡ªåŠ¨åˆ‡æ¢ + æ”¶ç›Šç›‘æ§
 */

const fs = require('fs');
const path = require('path');
const { createWalletClient, http } = require('viem');
const { privateKeyToAccount } = require('viem/accounts');
const { base } = require('viem/chains');

const PRIVATE_KEY = process.env.EVM_PRIVATE_KEY || '0x29b5a88baa09054abdbf18bfc6deaebe9acafd43a2730e5d42dae29f51e36675';
const WALLET = '0x1758DE3E2cf746F4eEb7143c3935fCa1B30060ce';

const USDC = '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913';
const AAVE_POOL = '0xa238dd80c259a72e81d7e4664a9801593f98d1c5';
const AAVE_ATOKEN = '0x4e65fe4dba92790696d040ac24aa414708f5c0ab';
const MORPHO = '0x8A034f069D59d62a4643ad42E49b846d036468D7';

const ERC20 = [
  { name: 'balanceOf', type: 'function', inputs: [{ name: 'owner', type: 'address' }], outputs: [{ type: 'uint256' }], stateMutability: 'view' }
];

const AAVE_ABI = [
  { name: 'supply', type: 'function', inputs: [{ name: 'asset', type: 'address' }, { name: 'amount', type: 'uint256' }, { name: 'onBehalfOf', type: 'address' }, { name: 'referralCode', type: 'uint16' }], outputs: [], stateMutability: 'nonpayable' },
  { name: 'withdraw', type: 'function', inputs: [{ name: 'asset', type: 'address' }, { name: 'amount', type: 'uint256' }, { name: 'to', type: 'address' }], outputs: [], stateMutability: 'nonpayable' }
];

const MORPHO_ABI = [
  { name: 'deposit', type: 'function', inputs: [{ name: 'assets', type: 'uint256' }, { name: 'receiver', type: 'address' }], outputs: [{ type: 'uint256' }], stateMutability: 'nonpayable' },
  { name: 'withdraw', type: 'function', inputs: [{ name: 'assets', type: 'uint256' }, { name: 'receiver', type: 'address' }, { name: 'owner', type: 'address' }], outputs: [{ type: 'uint256' }], stateMutability: 'nonpayable' }
];

const STATE_FILE = path.join(__dirname, '../data/state.json');
const LOG_FILE = path.join(__dirname, '../data/yield-history.json');

const dataDir = path.dirname(STATE_FILE);
if (!fs.existsSync(dataDir)) {
  fs.mkdirSync(dataDir, { recursive: true });
}

function loadState() {
  try {
    if (fs.existsSync(STATE_FILE)) {
      return JSON.parse(fs.readFileSync(STATE_FILE, 'utf8'));
    }
  } catch (e) {}
  return { shares: null, lastCheck: null, initialShares: null, initialValue: null };
}

function saveState(state) {
  fs.writeFileSync(STATE_FILE, JSON.stringify(state, null, 2));
}

function loadHistory() {
  try {
    if (fs.existsSync(LOG_FILE)) {
      return JSON.parse(fs.readFileSync(LOG_FILE, 'utf8'));
    }
  } catch (e) {}
  return [];
}

function saveHistory(history) {
  fs.writeFileSync(LOG_FILE, JSON.stringify(history, null, 2));
}

// è·å–å®æ—¶ APY - æ”¯æŒå¤šåè®®æ¯”è¾ƒ
async function fetchAPY(publicClient) {
  const result = { 
    protocols: {},  // å­˜å‚¨æ‰€æœ‰åè®®çš„ APY
    sources: {} 
  };
  
  // 1. ä½¿ç”¨ defi CLI è·å–å€Ÿè´·åè®®
  try {
    const { execSync } = require('child_process');
    
    // å°è¯•å¤šä¸ªåè®®
    const protocols = ['morpho', 'aave', 'compound', 'lido', 'yearn'];
    
    for (const proto of protocols) {
      try {
        const output = execSync(`defi lend rates --protocol ${proto} --chain base --asset USDC 2>/dev/null`, { encoding: 'utf8', timeout: 5000 });
        const data = JSON.parse(output);
        if (data.success && data.data.length > 0) {
          // å–æœ€é«˜ APY
          const maxApy = Math.max(...data.data.map(d => d.supply_apy));
          result.protocols[proto] = maxApy / 100;
          result.sources[proto] = 'defi-cli';
        }
      } catch (e) {
        // å¿½ç•¥å•ä¸ªåè®®é”™è¯¯
      }
    }
  } catch (e) {
    console.log('âš ï¸ defi CLI è·å–å¤±è´¥');
  }
  
  // 2. ä½¿ç”¨ DefiLlama è·å–æ›´å¤šåè®® (AMM/LP æ± )
  try {
    const response = await fetch('https://yields.llama.fi/pools');
    const data = await response.json();
    const pools = data.data || [];
    
    // æ‰¾ Base ä¸Š USDC ç›¸å…³çš„é«˜æ”¶ç›Šæ± 
    const usdcPools = pools.filter(p => 
      p.chain === 'Base' && 
      p.symbol === 'USDC' &&
      p.apy > 3  // > 3% APY
    ).sort((a, b) => b.apy - a.apy).slice(0, 5);
    
    for (const pool of usdcPools) {
      const proto = pool.project;
      if (!result.protocols[proto] || pool.apy / 100 > result.protocols[proto]) {
        result.protocols[proto] = pool.apy / 100;
        result.sources[proto] = 'defillama';
      }
    }
  } catch (e) {
    console.log('âš ï¸ DefiLlama è·å–å¤±è´¥');
  }
  
  // é»˜è®¤åè®®
  if (!result.protocols.aave) result.protocols.aave = 0.035;
  if (!result.protocols.morpho) result.protocols.morpho = 0.098;
  
  console.log(`ğŸ“¡ APY æ¥æº: ${Object.keys(result.protocols).map(k => `${k}=${result.sources[k]}`).join(', ')}`);
  return result;
}

async function main() {
  const action = process.argv[2] || 'check';
  
  const account = privateKeyToAccount(PRIVATE_KEY);
  const wallet = createWalletClient({ chain: base, transport: http(), account });
  const { createPublicClient } = require('viem');
  const publicClient = createPublicClient({ chain: base, transport: http() });

  console.log('=== Yield Aggregator (EOA) ===\n');

  // è·å–ä½™é¢
  const usdcBalance = await publicClient.readContract({ address: USDC, abi: ERC20, functionName: 'balanceOf', args: [WALLET] });
  const aaveBalance = await publicClient.readContract({ address: AAVE_ATOKEN, abi: ERC20, functionName: 'balanceOf', args: [WALLET] });
  const morphoSharesRaw = await publicClient.readContract({ address: MORPHO, abi: ERC20, functionName: 'balanceOf', args: [WALLET] });
  const morphoShares = Number(morphoSharesRaw) / 1e18;

  // è·å– APY
  const apy = await fetchAPY(publicClient);

  // åŠ è½½çŠ¶æ€
  const state = loadState();
  const now = Date.now();
  
  // è®¡ç®—æ”¶ç›Š
  let yieldInfo = { earned: 0, days: 0, apy: 0 };
  
  if (morphoShares > 0) {
    if (state.shares === null) {
      // é¦–æ¬¡è®°å½• - è®¾å®šåˆå§‹å€¼
      state.shares = morphoShares;
      state.lastCheck = now;
      state.initialShares = morphoShares;
      state.initialValue = 5; // ç”¨æˆ·å­˜å…¥ 5 USDC
      console.log('ğŸ“ é¦–æ¬¡è®°å½•æ”¶ç›ŠåŸºå‡†: 5 USDC');
    } else {
      const daysPassed = (now - state.lastCheck) / (1000 * 60 * 60 * 24);
      
      // è®¡ç®— share å˜åŒ–ç‡
      const shareRatio = morphoShares / state.initialShares;
      const currentValue = 5 * shareRatio;
      const earned = currentValue - 5;
      
      if (daysPassed > 0 && earned > 0) {
        yieldInfo.earned = earned;
        yieldInfo.days = daysPassed;
        yieldInfo.apy = (earned / 5 / daysPassed) * 365 * 100;
      }
      
      state.shares = morphoShares;
      state.lastCheck = now;
    }
    saveState(state);
  }

  // ä¿å­˜å†å²è®°å½•
  const history = loadHistory();
  history.push({
    time: new Date().toISOString(),
    shares: morphoShares,
    usdc: Number(usdcBalance) / 1e6,
    aave: Number(aaveBalance) / 1e6,
    apyAave: apy.aave * 100,
    apyMorpho: apy.morpho * 100,
    yield: yieldInfo.earned
  });
  if (history.length > 30) history.shift();
  saveHistory(history);

  // æ˜¾ç¤ºçŠ¶æ€
  console.log('ğŸ“Š å½“å‰çŠ¶æ€:');
  console.log(`  Wallet USDC: ${Number(usdcBalance) / 1e6}`);
  console.log(`  Aave aUSDC:  ${Number(aaveBalance) / 1e6}`);
  console.log(`  Morpho:     ${morphoShares.toFixed(4)} shares`);
  console.log('');

  if (action === 'check') {
    const totalAave = Number(aaveBalance) / 1e6;
    const totalMorpho = morphoShares;
    const principal = state.initialValue || 5;
    
    // æ”¶ç›Šæ¯”è¾ƒ - æ˜¾ç¤ºæ‰€æœ‰åè®®
    console.log('ğŸ“ˆ æ”¶ç›Šæ¯”è¾ƒ (å¤šåè®®):');
    
    // æ‰¾å‡ºæœ€é«˜ APY
    const sortedProtocols = Object.entries(apy.protocols)
      .sort((a, b) => b[1] - a[1]);
    
    let bestProto = null;
    let bestApy = 0;
    
    for (const [proto, apyValue] of sortedProtocols) {
      const annualYield = principal * apyValue;
      const isCurrent = (proto === 'morpho' && totalMorpho > 0) || (proto === 'aave' && totalAave > 0);
      const marker = isCurrent ? ' âœ…' : '';
      console.log(`  ${proto}: ${(apyValue * 100).toFixed(1)}% â†’ å¹´æ”¶ç›Š: $${annualYield.toFixed(4)}${marker}`);
      
      if (!bestProto || apyValue > bestApy) {
        bestProto = proto;
        bestApy = apyValue;
      }
    }
    console.log('');
    
    // æ˜¾ç¤ºå®é™…æ”¶ç›Š
    if (yieldInfo.earned > 0) {
      console.log('ğŸ’° å®é™…æ”¶ç›Š (åŸºäº share å¢é•¿):');
      console.log(`  ç´¯è®¡æ”¶ç›Š: $${yieldInfo.earned.toFixed(4)} USDC`);
      console.log(`  ç»è¿‡å¤©æ•°: ${yieldInfo.days.toFixed(1)} å¤©`);
      console.log(`  æ¨ç®—å¹´åŒ–: ${yieldInfo.apy.toFixed(2)}%`);
      console.log('');
    }
    
    // å»ºè®®
    const currentProto = totalMorpho > 0 ? 'morpho' : (totalAave > 0 ? 'aave' : null);
    if (currentProto && currentProto !== bestProto) {
      console.log(`ğŸ¯ å»ºè®®: ä» ${currentProto} åˆ‡æ¢åˆ° ${bestProto} (å¤šèµš ${((bestApy - apy.protocols[currentProto]) * 100).toFixed(1)}%)`);
    } else if (currentProto === bestProto) {
      console.log(`ğŸ’¤ å½“å‰å·²æ˜¯æœ€é«˜æ”¶ç›Š (${bestProto})`);
    } else {
      console.log(`ğŸ’¡ å»ºè®®: å­˜å…¥ ${bestProto} (APY: ${(bestApy * 100).toFixed(1)}%)`);
    }
    return;
  }

  // history å‘½ä»¤
  if (action === 'history') {
    console.log('ğŸ“ˆ æ”¶ç›Šå†å²:\n');
    history.forEach(h => {
      const date = new Date(h.time).toLocaleDateString();
      console.log(`${date}: ${h.shares?.toFixed(4) || 0} shares | æ”¶ç›Š: $${h.yield?.toFixed(4) || 0}`);
    });
    return;
  }

  // auto å‘½ä»¤ - è‡ªåŠ¨æ‰§è¡Œåˆ‡æ¢
  if (action === 'auto') {
    const currentProto = totalMorpho > 0 ? 'morpho' : (totalAave > 0 ? 'aave' : null);
    
    if (!currentProto) {
      console.log('ğŸ’¤ æ— å­˜æ¬¾ï¼Œéœ€è¦å…ˆå­˜å…¥');
      return;
    }
    
    // æ‰¾å‡ºæœ€é«˜æ”¶ç›Šåè®®
    const sortedProtocols = Object.entries(apy.protocols)
      .sort((a, b) => b[1] - a[1]);
    const bestProto = sortedProtocols[0][0];
    const bestApy = sortedProtocols[0][1];
    const currentApy = apy.protocols[currentProto];
    
    // åˆ‡æ¢é˜ˆå€¼ï¼šæ”¶ç›Šå·® > 1% æ‰åˆ‡æ¢
    const threshold = 0.01;
    const diff = bestApy - currentApy;
    
    if (bestProto === currentProto) {
      console.log(`ğŸ’¤ å½“å‰å·²æ˜¯æœ€é«˜æ”¶ç›Š (${bestProto} @ ${(bestApy*100).toFixed(1)}%)`);
      return;
    }
    
    if (diff < threshold) {
      console.log(`ğŸ’¤ æ”¶ç›Šå·® ${(diff*100).toFixed(2)}% < ${(threshold*100)}%ï¼Œä¸åˆ‡æ¢`);
      return;
    }
    
    console.log(`ğŸ”„ è‡ªåŠ¨åˆ‡æ¢: ${currentProto} (${(currentApy*100).toFixed(1)}%) â†’ ${bestProto} (${(bestApy*100).toFixed(1)}%)`);
    console.log(`   æ”¶ç›Šå·®: ${(diff*100).toFixed(2)}%\n`);
    
    // æ‰§è¡Œåˆ‡æ¢
    if (currentProto === 'aave' && bestProto === 'morpho') {
      // Aave â†’ Morpho
      console.log('1ï¸âƒ£ ä» Aave å–æ¬¾...');
      const withdrawTx = await wallet.writeContract({
        address: AAVE_POOL, abi: AAVE_ABI, functionName: 'withdraw',
        args: [USDC, aaveBalance, WALLET]
      });
      console.log(`   TX: https://basescan.org/tx/${withdrawTx}`);
      
      await new Promise(r => setTimeout(r, 5000));
      
      console.log('2ï¸âƒ£ Approve...');
      await wallet.writeContract({
        address: USDC, abi: ERC20, functionName: 'approve',
        args: [MORPHO, aaveBalance]
      });
      
      console.log('3ï¸âƒ£ å­˜å…¥ Morpho...');
      const depositTx = await wallet.writeContract({
        address: MORPHO, abi: MORPHO_ABI, functionName: 'deposit',
        args: [aaveBalance, WALLET]
      });
      console.log(`   TX: https://basescan.org/tx/${depositTx}`);
      
      console.log('\nâœ… åˆ‡æ¢å®Œæˆ!');
    } 
    else if (currentProto === 'morpho' && bestProto === 'aave') {
      // Morpho â†’ Aave
      console.log('1ï¸âƒ£ ä» Morpho å–æ¬¾...');
      const withdrawTx = await wallet.writeContract({
        address: MORPHO, abi: MORPHO_ABI, functionName: 'withdraw',
        args: [morphoSharesRaw, WALLET, WALLET]
      });
      console.log(`   TX: https://basescan.org/tx/${withdrawTx}`);
      
      await new Promise(r => setTimeout(r, 5000));
      
      console.log('2ï¸âƒ£ Approve...');
      const usdcBal = await publicClient.readContract({ address: USDC, abi: ERC20, functionName: 'balanceOf', args: [WALLET] });
      await wallet.writeContract({
        address: USDC, abi: ERC20, functionName: 'approve',
        args: [AAVE_POOL, usdcBal]
      });
      
      console.log('3ï¸âƒ£ å­˜å…¥ Aave...');
      const depositTx = await wallet.writeContract({
        address: AAVE_POOL, abi: AAVE_ABI, functionName: 'supply',
        args: [USDC, usdcBal, WALLET, 0]
      });
      console.log(`   TX: https://basescan.org/tx/${depositTx}`);
      
      console.log('\nâœ… åˆ‡æ¢å®Œæˆ!');
    }
    else {
      console.log(`âš ï¸ æš‚ä¸æ”¯æŒ ${currentProto} â†’ ${bestProto} çš„è‡ªåŠ¨åˆ‡æ¢`);
      console.log('   ç›®å‰ä»…æ”¯æŒ Aave â†” Morpho');
    }
    return;
  }

main().catch(console.error);
